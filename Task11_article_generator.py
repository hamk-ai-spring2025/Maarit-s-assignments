"""
Article Generator with APA-style References Checker
===================================================
A single‑file command‑line utility that
1. Prompts Google Gemini (via the Generative AI Python SDK) to draft a full scientific
   article (Markdown) with APA in‑text citations and a reference list.
2. Converts the Markdown to a structured PDF.
3. Validates every reference against the Crossref Works API and reports
   which ones could not be verified (potential hallucinations).

Usage
-----
$ export GOOGLE_API_KEY="<your‑API‑key>"
$ python Task11_article_generator.py "Quantum entanglement in photosynthesis"

Requirements
------------
python‑3.9+
```bash
pip install google‑generativeai markdown pypandoc requests rich
# plus: system pandoc & LaTeX for PDF (e.g. sudo apt‑get install pandoc texlive‑full)
```

Notes
-----
*  The script keeps all generated artefacts in an output/ folder named with
   the slugified topic and a timestamp.
*  Reference verification is heuristic: a reference is *valid* if Crossref
   returns at least one work whose title contains **all** the first four
   words (case‑insensitive) of the cited work’s title.
*  The code is intentionally verbose & annotated for clarity. Feel free to
   refactor logging, error handling, or prompt engineering for your needs.
"""
from __future__ import annotations

import argparse
import json
import os
import re
import subprocess
import sys
import textwrap
from datetime import datetime
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import List, Tuple

import google.generativeai as genai
import markdown  # only used to strip markdown for the Crossref query fallback
import requests
from rich.console import Console
from rich.table import Table

console = Console()

# ----------------------------- CONFIGURATION ----------------------------- #
MODEL_NAME = "gemini-1.5-pro" 
MAX_TOKENS = 6144  # generous so we can get long articles
TEMPERATURE = 0.7

# PDF / LaTeX defaults – tweak to taste
PAPER_SIZE = "a4paper"
MARGIN_MM = 25  # single margin value for all sides
LINE_STRETCH_EMERG = "3em"  # emergency stretch for stubborn long lines

HEADERS = {
    "Content-Type": "application/json",
    "User-Agent": "APA-Checker/1.0 (mailto:you@example.com)",
}
CROSSREF_ENDPOINT = "https://api.crossref.org/works"

PROMPT_TEMPLATE = textwrap.dedent(
    """
    You are an academic writing assistant.
    Produce a full scientific article in **Markdown** on the following TOPIC.

    Requirements:
    1. Follow the IMRaD structure *and* include Abstract, Introduction, Methods,
       Results (tables allowed using markdown pipe syntax), Discussion, and Conclusions.
    2. Embed **APA‑style in‑text citations** *and* finish with a **References**
       section in **APA 7th edition format**.
    3. Provide at least 8 distinct scholarly sources (journal papers preferred).

    TOPIC: """  # <- topic will be appended here
)

# --------------------------- HELPER FUNCTIONS --------------------------- #


def slugify(text: str) -> str:
    return re.sub(r"[^\w-]+", "-", text.lower()).strip("-")


def ensure_output_dir(topic: str) -> Path:
    ts = datetime.now().strftime("%Y%m%d-%H%M%S")
    out_dir = Path("output") / f"{slugify(topic)}-{ts}"
    out_dir.mkdir(parents=True, exist_ok=True)
    return out_dir


def call_gemini(topic: str) -> str:
    console.print("[bold blue]▶ Generating article with Gemini…[/]")
    genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
    model = genai.GenerativeModel(MODEL_NAME)
    prompt = PROMPT_TEMPLATE + topic + "\n"  # append topic at the end

    response = model.generate_content(prompt, generation_config={
        "max_output_tokens": MAX_TOKENS,
        "temperature": TEMPERATURE,
    })
    markdown_text = response.text  # .text returns the markdown body
    return markdown_text

def _build_header_tex() -> Path:
    """Return a tiny *.tex file to improve line breaking and URLs."""
    header = textwrap.dedent(
        rf"""
        % Auto‑generated by article_generator.py
        \usepackage{{xurl}}    % better URL line breaks
        \usepackage{{array}}   % for p{{}} column types
        \usepackage{{makecell}} % for better table cell formatting
        \usepackage{{longtable}}  % for wrapping long table rows
        \setlength\emergencystretch{{3em}}  % allow TeX to stretch lines
        \sloppy  % allow line breaks at almost any point
        """
    )
    tmp = NamedTemporaryFile(mode="w", suffix=".tex", delete=False, encoding="utf-8")
    tmp.write(header)
    tmp.close()
    return Path(tmp.name)

def enforce_line_breaks(markdown_text: str, max_line_length: int = 80) -> str:
    """Insert line breaks in Markdown content to ensure lines fit within a specified length."""
    processed_lines = []
    for line in markdown_text.splitlines():
        if len(line) > max_line_length:
            # Break the line into chunks of max_line_length
            while len(line) > max_line_length:
                split_idx = line.rfind(" ", 0, max_line_length)
                if split_idx == -1:  # No space found, force break
                    split_idx = max_line_length
                processed_lines.append(line[:split_idx] + "  ")  # Add two spaces for Markdown line break
                line = line[split_idx:].lstrip()
            processed_lines.append(line)
        else:
            processed_lines.append(line)
    return "\n".join(processed_lines)


def markdown_to_pdf(md_path: Path, pdf_path: Path) -> None:
    console.print("[bold blue]▶ Converting Markdown ⇒ PDF with pandoc…[/]")
    # Read the Markdown content
    markdown_text = md_path.read_text(encoding="utf-8")
    
    # Enforce line breaks
    markdown_text = enforce_line_breaks(markdown_text)
    
    # Save the modified Markdown back to the file
    md_path.write_text(markdown_text, encoding="utf-8")
    
    # Generate the LaTeX header
    header_path = _build_header_tex()
    geometry_opt = f"{PAPER_SIZE},margin={MARGIN_MM}mm"
    cmd = [
        "pandoc",
        str(md_path),
        "--from", "markdown+pipe_tables+yaml_metadata_block",
        "--pdf-engine=xelatex",
        "--toc",
        "--variable", f"geometry:{geometry_opt}",
        "--include-in-header", str(header_path),  # Include custom LaTeX header
        "-o", str(pdf_path),
    ]
    subprocess.run(cmd, check=True)
    header_path.unlink(missing_ok=True)

def extract_references(markdown_text: str) -> List[str]:
    """Return each reference line (APA style) as found under 'References'."""
    refs_section = re.split(r"\n#+\s*References\b", markdown_text, flags=re.I)
    if len(refs_section) < 2:
        return []
    after_refs = refs_section[1]
    lines = [ln.strip(" \t-•") for ln in after_refs.splitlines()]
    # stop at first empty heading or major section
    stop_idx = next((i for i, ln in enumerate(lines) if re.match(r"^#+ ", ln)), len(lines))
    refs = [ln for ln in lines[:stop_idx] if ln]
    return refs


def query_crossref(title_start: str) -> bool:
    params = {"query.bibliographic": title_start, "rows": 1}
    r = requests.get(CROSSREF_ENDPOINT, params=params, headers=HEADERS, timeout=15)
    if r.status_code != 200:
        return False
    data = r.json()
    return bool(data.get("message", {}).get("items"))


def check_reference(ref: str) -> Tuple[str, bool]:
    """Return (reference, is_valid)"""
    # crude title extraction: between year) and . (next period)
    m = re.search(r"\)\s*(.+?)\.", ref)
    if not m:
        return ref, False
    title = m.group(1)
    # first four words (remove markdown italics etc.)
    plain = re.sub(r"[_*`~]", "", title)
    first4 = " ".join(plain.split()[:4])
    is_valid = query_crossref(first4)
    return ref, is_valid


def verify_references(refs: List[str]) -> List[Tuple[str, bool]]:
    console.print("[bold blue]▶ Verifying references via Crossref…[/]")
    return [check_reference(r) for r in refs]


def pretty_report(results: List[Tuple[str, bool]]):
    table = Table(title="Reference Validation")
    table.add_column("#", justify="right")
    table.add_column("Reference (truncated)")
    table.add_column("Valid?", justify="center")
    for i, (ref, ok) in enumerate(results, 1):
        trunc = (ref[:95] + "…") if len(ref) > 100 else ref
        table.add_row(str(i), trunc, "✅" if ok else "❌")
    console.print(table)
    total = len(results)
    invalid = sum(1 for _, ok in results if not ok)
    console.print(f"[bold]{total - invalid}/{total} references verified ("f"{invalid} hallucination{'s' if invalid != 1 else ''}).[/]")

# ------------------------------- MAIN CLI ------------------------------- #

def main():
    parser = argparse.ArgumentParser(description="Generate a PDF scientific article with APA references using Gemini and verify them via Crossref.")
    parser.add_argument("topic", help="Article topic in one sentence or phrase")
    args = parser.parse_args()

    out_dir = ensure_output_dir(args.topic)

    markdown_text = call_gemini(args.topic)
    md_path = out_dir / "article.md"
    md_path.write_text(markdown_text, encoding="utf-8")

    pdf_path = out_dir / "article.pdf"
    markdown_to_pdf(md_path, pdf_path)
    console.print(f"[green]PDF saved to {os.path.relpath(pdf_path, Path.cwd())}[/]")

    references = extract_references(markdown_text)
    if not references:
        console.print("[bold red]✖ No references section detected.[/]")
        sys.exit(1)

    results = verify_references(references)
    pretty_report(results)

    # Save verification results as JSON
    report_json = out_dir / "reference_report.json"
    json.dump([{"reference": r, "valid": ok} for r, ok in results], report_json.open("w", encoding="utf-8"), indent=2)
    console.print(f"[green]Validation report saved to {os.path.relpath(report_json, Path.cwd())}[/]")


if __name__ == "__main__":
    main()
